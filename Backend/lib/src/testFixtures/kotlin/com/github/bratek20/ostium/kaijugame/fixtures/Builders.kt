// DO NOT EDIT! Autogenerated by HLA tool

package com.github.bratek20.ostium.kaijugame.fixtures

import com.github.bratek20.ostium.gamesmanagement.api.*
import com.github.bratek20.ostium.gamesmanagement.fixtures.*

import com.github.bratek20.ostium.kaijugame.api.*

data class AttackReceiverDef(
    var type: String = DamageType.Light.name,
    var myDamage: Int = 0,
    var opponentDamage: Int = 0,
)
fun attackReceiver(init: AttackReceiverDef.() -> Unit = {}): AttackReceiver {
    val def = AttackReceiverDef().apply(init)
    return AttackReceiver.create(
        type = DamageType.valueOf(def.type),
        myDamage = def.myDamage,
        opponentDamage = def.opponentDamage,
    )
}

data class AttackGiverDef(
    var type: String = DamageType.Light.name,
    var damageValue: Int = 0,
)
fun attackGiver(init: AttackGiverDef.() -> Unit = {}): AttackGiver {
    val def = AttackGiverDef().apply(init)
    return AttackGiver.create(
        type = DamageType.valueOf(def.type),
        damageValue = def.damageValue,
    )
}

data class PlayerSideDef(
    var pool: (AttackPoolDef.() -> Unit) = {},
    var playedCards: List<(CardDef.() -> Unit)> = emptyList(),
)
fun playerSide(init: PlayerSideDef.() -> Unit = {}): PlayerSide {
    val def = PlayerSideDef().apply(init)
    return PlayerSide.create(
        pool = attackPool(def.pool),
        playedCards = def.playedCards.map { it -> card(it) },
    )
}

data class HitZoneDef(
    var position: String = HitZonePosition.Left.name,
    var lightReceiver: (AttackReceiverDef.() -> Unit) = {},
    var mediumReceiver: (AttackReceiverDef.() -> Unit) = {},
    var heavyReceiver: (AttackReceiverDef.() -> Unit) = {},
)
fun hitZone(init: HitZoneDef.() -> Unit = {}): HitZone {
    val def = HitZoneDef().apply(init)
    return HitZone.create(
        position = HitZonePosition.valueOf(def.position),
        lightReceiver = attackReceiver(def.lightReceiver),
        mediumReceiver = attackReceiver(def.mediumReceiver),
        heavyReceiver = attackReceiver(def.heavyReceiver),
    )
}

data class AttackPoolDef(
    var lightGiver: (AttackGiverDef.() -> Unit) = {},
    var mediumGiver: (AttackGiverDef.() -> Unit) = {},
    var heavyGiver: (AttackGiverDef.() -> Unit) = {},
    var focusLeft: Int = 0,
)
fun attackPool(init: AttackPoolDef.() -> Unit = {}): AttackPool {
    val def = AttackPoolDef().apply(init)
    return AttackPool.create(
        lightGiver = attackGiver(def.lightGiver),
        mediumGiver = attackGiver(def.mediumGiver),
        heavyGiver = attackGiver(def.heavyGiver),
        focusLeft = def.focusLeft,
    )
}

data class TableDef(
    var leftZone: (HitZoneDef.() -> Unit) = {},
    var centerZone: (HitZoneDef.() -> Unit) = {},
    var rightZone: (HitZoneDef.() -> Unit) = {},
    var mySide: (PlayerSideDef.() -> Unit) = {},
    var opponentSide: (PlayerSideDef.() -> Unit) = {},
)
fun table(init: TableDef.() -> Unit = {}): Table {
    val def = TableDef().apply(init)
    return Table.create(
        leftZone = hitZone(def.leftZone),
        centerZone = hitZone(def.centerZone),
        rightZone = hitZone(def.rightZone),
        mySide = playerSide(def.mySide),
        opponentSide = playerSide(def.opponentSide),
    )
}

data class CardDef(
    var type: String = DamageType.Light.name,
    var value: Int = 0,
    var focusCost: Int = 0,
)
fun card(init: CardDef.() -> Unit = {}): Card {
    val def = CardDef().apply(init)
    return Card.create(
        type = DamageType.valueOf(def.type),
        value = def.value,
        focusCost = def.focusCost,
    )
}

data class HandDef(
    var cards: List<(CardDef.() -> Unit)> = emptyList(),
)
fun hand(init: HandDef.() -> Unit = {}): Hand {
    val def = HandDef().apply(init)
    return Hand.create(
        cards = def.cards.map { it -> card(it) },
    )
}

data class GameStateDef(
    var turn: Int = 0,
    var phase: String = TurnPhase.PlayCard.name,
    var table: (TableDef.() -> Unit) = {},
    var hand: (HandDef.() -> Unit) = {},
    var myReady: Boolean = false,
    var opponentReady: Boolean = false,
)
fun gameState(init: GameStateDef.() -> Unit = {}): GameState {
    val def = GameStateDef().apply(init)
    return GameState.create(
        turn = def.turn,
        phase = TurnPhase.valueOf(def.phase),
        table = table(def.table),
        hand = hand(def.hand),
        myReady = def.myReady,
        opponentReady = def.opponentReady,
    )
}